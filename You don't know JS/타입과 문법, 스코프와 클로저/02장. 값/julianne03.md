## 02. 값


### 2.0 서론

배열, 문자열, 숫자는 모든 프로그램의 가장 기본적인 구성 요소지만 자바스크립트에서는 독특한 특성을 갖고 있다.<br>
그로 인해 개발자를 웃게도, 울게도 만든다.<br>
자바스크립트에 내장된 값 타입과 작동 방식을 살펴보고 정확하게 사용할 수 있도록 완전히 이해하자.<br>

</br>

### 2.1 배열

자바스크립트 배열은 타입이 엄격한 다른 언어와 달리 문자열, 숫자, 객체 심지어 다른 배열이나 어떤 타입의 값이라도 담을 수 있는 그릇이다.
```
// 배열 크기를 미리 정하지 않아도 된다.
const a = [1, "2", [3]];

// 구멍 난 배열을 다룰 때는 조심해야 한다.
let a = [];

a[0] = 1;
a[2] = [3];
console.log(a[1]); // undefined
// a[1] 값을 넣지 않아도 자동으로 undefined 값으로 세팅된다.
console.log(a.length); // 3

// 배열 인덱스는 숫자이지만 배열 자체도 하나의 객체여서 키/프로퍼티 문자열을 추가할 수 있다.
let a = [];

a[0] = 1;
a["foobar"] = 2;

// 하지만 배열 length가 증가하지 않는다.
console.log(a["foobar"]); // 2
console.log(a.length); // 1

// 주의해야할 점
// 만약 키로 넣은 문자열 값이 표준 10진수 숫자로 타입이 바뀌면 숫자 키를 사용한 것과 같은 결과가 초래된다.
let a = [];

a["13"] = 42;
console.log(a.length); // 14
```
일반적으로 배열에 문자열 타입의 키/프로퍼티를 두는 걸 추천하고 싶지 않다. <br>
그렇게 해야 한다면 객체를 대용하고 배열 원소의 인덱스는 확실히 숫자만 쓰자.

</br>

### 2.2 문자열

흔히 문자열은 단지 문자의 배열이라고 생각한다.<br>
자바스크립트 문자열은 실제로 생김새만 비슷할 뿐 문자 배열과 같지 않다.
```
const a = "foo";
const b = ["f", "o", "o"];

a[1] = "O";
b[1] = "O";

// 문자열은 불변 값이지만 배열은 가변 값이다.
console.log(a); // "foo"
console.log(b); // ["f", "O", "o"]

// 한가지 더, 문자열은 불변 값이므로 문자열 메서드는 그 내용을 바로 변경하지 않고 항상 새로운 문자열을 생성한 후 반환한다.
a.toUpperCase();
console.log(a); // "foo";

// 반면에 대부분의 배열 메서드는 그 자리에서 곧바로 원소를 수정한다.
b.push("!");
console.log(b); // ["f", "O", "o", "!"]

// 문자열은 배열의 메서드를 빌려 쓸 수 없다.
a.reverse(); // undefined
b.reverse(); // ["!", "o", "O", "f"]

// 문자열을 배열로 바꾸고 원하는 작업을 수행한 후 다시 문자열을 되돌리는 것이 또 다는 꼼수(핵)이다.
const c = a.split("").reverse().join(""); // "oof"
```

</br>

### 2.3 숫자

자바스크립트의 숫자 타입은 `number`가 유일하며 정수, 부동 소수점 숫자를 모두 아우른다.<br>
ex. 자바스크립트에서 42.0은 '정수' 42와 같다.

#### 2.3.1 숫자 구문

자바스크립트 숫자 리터럴은 다음과 같이 10진수 리터럴로 표시한다.
```
const a = 42;
const b = 42.3;

const a = .42; // 0.42와 같다.
const b = 42.; // 42.0과 같다.

// 대부분의 숫자는 10진수가 디폴트고 소수점 이하 0은 뗀다.
const a = 42.300; // 42.3
const b = 42.0; // 42

const a = 42.59;

// toFixed() 메서드는 지정한 소수점 이하 자릿수까지 숫자를 나타낸다.
a.toFixed(0); // "43"

// toPrecision() 메서드도 기능은 비슷하지만 유효 숫자 개수를 지정할 수 있다.
a.toPrecision(1); // "4e+1"
```

#### 2.3.2 작은 소수 값
```
// 수식만 보면 분명 `true`이지만 이진 부동 소수점으로 나타낸 0.1과 0.2는 원래의 숫자와 일치하지 않는다.
// 그래서 실제 둘을 더한 결과는 0.3000000000004에 가깝지만 '가깝다고' 해도 '같은' 것은 아니다.
0.1 + 0.2 === 0.3; // false

// 이 둘을 비교하는 가장 일반적인 방법으로는 '미세한 반올림 오차'를 '허용 공차'로 처리하는 방법이 있다.
// ES6부터는 이 값이 `Number.EPSILON`으로 미리 정의되어 있으므로 필요시 사용하면 된다.
```

#### 2.3.3 안전한 정수 범위
'안전하게' 표현할 수 있는 최대 정수 값을 ES6에서 `Number.MAX_SAFE_INTEGER`로 정의한다.<br>
최솟값은 `Number.MAX_SAFE_INTEGER`이다.

#### 2.3.4 정수인지 확인
ES6부터는 `Number.isInteger()`로 어떤 값의 정수 여부를 확인한다.
```
Number.isInteger(42); // true
Number.isInteger(42.000); // true
Number.isInteger(42.3); // false
```

</br>

### 2.4 특수 값
타입별로 자바스크립트 개발자들이 조심해서 사용해야 할 특수한 값들이 있다.

#### 2.4.1 값 아닌 값
undefined 타입의 값은 undefined밖에 없다.<br>
null 타입도 값은 null 뿐이다.<br>
그래서 이 둘은 타입과 항상 값이 같다.<br>

`undefined`와 `null`의 의미를 어떻게 '정의'하여 쓰든지 `null`은 식별자가 아닌 특별한 키워드이므로 `null`이라는 변수에 뭔가를 할당할 수는 없다.<br>
그런데 불행히도 `undefined`는 식별자로 쓸 수 있다.

#### 2.4.2 undefined
느슨한 모드에서는 전역 스코프에서 `undefined`란 식별자에 값을 할당할 수 있지만 절대 하지말아라.<br>
좋은 코드를 짜는 사람이라면 `undefined`를 재정의하도록 내버려두지 않을 것이다.
`undefined`는 내장 식별자로, 값은 `undefined`지만, 이 값은 `void` 연산자로도 얻을 수 있다.<br>

#### 2.4.3 특수 숫자
숫자 타입에는 몇 가지 특수한 값이 있다.
- NaN (Not a Number)
  - 수학 연산 시 두 피연산자가 전부 숫자가 아닐 경우 유효한 숫자가 나올 수 없으므로 그 결과는 NaN이다.
  - 유효하지 않은 숫자, 실패한 숫자, 몹쓸 숫자
  - Number.isNaN() 함수가 NaN 여부를 체크할 수 있다.
- 무한대
  - JS에는 0으로 나누기 연산이 잘 정의되어 있어서 에러 없이 `Infinity`라는 결과값이 나온다.
  - 분자가 음수면 나누기 결과값은 `-Infinity`다.
- 영(0)

#### 2.4.4 특이한 동등 비교
ES6부터는 잡다한 예외를 걱정하지 않아도 두 값이 절대적으로 동등한지를 확인하는 `Object.is()`를 지원한다.</br>
`==`나 `===`가 안전하다면 굳이 `Object.is()`는 사용하지 않는 편이 좋다.

</br>

### 2.5 값 VS 레퍼런스
`null`, `undefined`, `string`, `number`, `boolean`, `symbol` 같은 단순 값은 언제나 값-복사 방식으로 할당/전달된다.</br>
객체나 함수 등 합성 값은 할당/전달 시 반드시 레퍼런스 사본을 생성한다.</br>
자바스크립트에 포인터란 없다!
