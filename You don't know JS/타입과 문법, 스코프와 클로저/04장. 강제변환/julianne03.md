## 04. 강제변환

### 4.0 서론

강제변환이 유용한 기능인지, 언어 설계상 결함인지는 처음부터 큰 논란거리였다.<br>
이 장의 목적은 강제변환의 좋고 나쁨을 충분히 이해하고 자신의 프로그램에 적절한지 스스로 판단할 수 있는 역량을 갖추도록 돕는 것이다.

<br>

### 4.1 값 변환

어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적이면 **'타입 캐스팅'**, 암시적이면 **'강제변환'** 이라고 한다.<br>
두 용어를 이렇게 구분하는 사람들도 있다.

- **타입 캐스팅**: 정적 타입 언어에서 컴파일 시점에 발생한다.
- **강제변환**: 동적 타입 언어에서 런타임 시점에 발생한다.

그러나 자바스크립트에서는 대부분 모든 유형의 타입변환을 강제변환으로 뭉뚱그려 일컫는 경향이 있어서,<br>
여기서는 **암시적 강제변환**과 **명시적 강제변환** 두 가지로 구별하겠다.<br>
차이는 명확하다.

- **암시적 강제변환**: 코드만 봐도 의도적으로 타입변환을 일으킨다.
- **명시적 강제변환**: 다른 작업 도중 불분명한 부수 효과로부터 발생하는 타입변환이다.

```
const a = 42;
const b = a + ""; // 암시적 타입변환
const c = String(a); // 명시적 타입변환
```
<br>

### 4.2 추상 연산

명시적/암시적 강제변환의 세계로 떠나기 전에 어떻게 값이 문자열, 숫자, 불리언 등의 타입이 되는지, 그 기본 규칙을 알아보자.

- **toString()**
  ```
  // "문자열 아닌 값" -> "문자열"
  const a = 1000 * 1.07;
  a.toString(); // "1070"
  const b = [1, 2, 3];
  b.toString(); // "1, 2, 3"
  ```
- **JSON 문자열화**
  ```
  // ToString은 JSON.stringify() 유틸리티를 사용하여 어떤 값을 JSON 문자열로 직렬화하는 문제와도 연관된다.
  const a = { b: 2, c: function(){} }
  JSON.stringify(a); // "{ "b": 2 }"
  // toJSON()의 역할은 '문자열화하기 적당한 JSON 안전 값으로 바꾸는 것 (JSON 문자열로 바꾸는 것 X)
  ```
- **Number()**
  ```
  // 숫자 아닌 값 -> 수식 연산이 가능한 숫자
  const a = "42";
  Number(a); // 42
  const b = [4, 2];
  b.toString = function() {
    return this.join(");
  }
  Number(b); // 42
  ```
- **Boolean()**
  - 1을 `true`로, 0을 `false`로 강제변환할 수는 있지만 그렇다고 두 값이 똑같은 건 아니다.
  - **Falsy 값**
    - 자바스크립트의 모든 값은 다음 둘 중 하나다.
      1. 불리언으로 강제변환하면 `false`가 되는 값
      2. 1번을 제외한 나머지 (즉, 명백히 `true`인 값)
    - 명세가 정의한 'falsy' 값은 다음과 같다.
      - `undefined`, `null`, `false`, `+0`, `-0`, `NaN`, `""`
  - **Truthy 값**
    -  Falsy 값 목록에 없으면 무조건 Truthy 값이다.
  - `truthy`/`falsy` 개념은 어떤 값을 불리언 타입으로 강제변환 시 해당 값의 작동방식을 이해한다는 점에서 중요하다.
<br>

### 4.3 명시적 강제변환

**명시적 강제변환**은 분명하고 확실한 타입변환이다.<br>
이 절의 목적은 훗날 다른 개발자가 본인이 작성한 코드로 인해 구렁텅이에 빠지지 않도록 값의 타입변환 과정을 분명하고 명확하게 할 수 있는 패턴을 스스로 찾게 하는 것이다.

1. **문자열 -> 숫자**<br>
  가장 간단하면서도 가장 잦은 강제변환이라 할 수 있다.<br>
  `String()`, `Number()` 메서드를 사용한다.

