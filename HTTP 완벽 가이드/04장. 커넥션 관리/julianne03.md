# 04. 커넥션 관리

## 4.0 Intro

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

<br>

## 4.1 TCP 커넥션

- TCP/IP 커넥션을 맺으면 클라이언트와 서버 간에 주고받는 메시지들은 안전하게 전달된다.

<br>

**웹 브라우저가 TCP 커넥션을 통해 웹 서버에 요청을 보내는 순서**

1. 브라우저가 요청된 url에서 호스트명을 추출한다.
2. 브라우저가 이 호스트 명에 대한 IP 주소를 찾는다.
3. 브라우저가 포트 번호를 얻는다.
4. 브라우저가 IP 주소의 포트로 TCP 커넥션을 생성한다.
5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.
6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다.
7. 브라우저가 커넥션을 끊는다.

<br>

### 4.1.1 신뢰할 수 있는 데이터 전송 통로안 TCP

- TCP 커넥션은 인터넷을 안정적으로 연결해준다.
- TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다.

<br>

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터를 전송한다.
- HTTP는 프로토콜 스택에서 **최상위 계층**에 해당된다.

> <img width="400" src="https://user-images.githubusercontent.com/59498977/130308297-93dffd9a-5007-4d6a-b02a-d8acfa31916c.png">
>
> HTTP와 HTTPS 네트워크 프로토콜 스택

<br>

**HTTP가 메시지를 보내는 경로**

1. TCP 세그먼트라는 단위로 데이터 스트림을 잘게 나눈다.
2. 세그먼트를 IP 패킷이라고 불리는 봉투에 담아 인터넷을 통해 데이터를 전달한다.

<br>

**TCP 세그먼트 구성 요소**

- IP 패킷 헤더
- TCP 세그먼트 헤더
- TCP 데이터 조각

> <img width="400" src="https://user-images.githubusercontent.com/59498977/130308410-a58effe4-047d-40a6-ba96-81eda96b41a8.png">
>
> IP 패킷의 구조

<br>

### 4.1.3 TCP 커넥션 유지하기

- TCP는 포트 번호를 통해서 여러 개의 커넥션을 유지한다.
- TCP 커넥션은 네 가지 값으로 유일한 커넥션을 생성한다.
- `<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>`

<br>

### 4.1.4 TCP 소켓 프로그래밍

- 소켓 API를 사용하면, TCP 종단 데이터 구조를 생성할 수 있다.
- 또한, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
  > <img src="https://user-images.githubusercontent.com/59498977/130308745-d2a45a68-15b9-4f40-ab3f-dced45312532.png">

<br>

## 4.2 TCP의 성능에 대한 고려

- HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

<br>

### 4.2.1 HTTP 트랜잭션 지연

- TCP 네트워크 지연으로 인해 대부분의 HTTP 지연이 발생한다.

<br>

**HTTP 트랜잭션을 지연시키는 원인**

1. 방문 기록이 없을 경우, DNS를 사용하여 호스트 명을 변환해야 한다.
2. 클라이언트가 TCP 커넥션 요청을 서버에게 보내고 서버가 응답하기를 기다린다.
3. 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송한다.
4. 웹 서버가 HTTP 응답을 보내는 시간이 걸린다.

<br>

## 4.3 HTTP 커넥션 관리

- 커넥션을 생성하고 최적화하는 HTTP 기술에 대해 다룰 것이다.
- HTTP 커넥션 헤더에 대해 알아볼 것이다.

<br>

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- Connection 헤더에는 다음 세 가지 종류의 토큰이 전달된다.

  - HTTP 헤더 필드 명은 이 커넥션에만 해당되는 헤더들을 나열한다.
  - 임시적인 토큰 값은 커넥션에 대한 비표준 옵션을 의미한다.
  - close 값은 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.

<br>

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- HTTP 커넥션의 성능을 향상시킬 수 있는 여러 최신 기술

  - 병렬 커넥션
  - 지속 커넥션
  - 파이프라인 커넥션
  - 다중 커넥션

<br>

## 4.4 병렬 커넥션

- HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

> <img width="400" src="https://user-images.githubusercontent.com/59498977/130309622-178c6350-9abe-4a7e-8d30-cd600c3f6f45.png">

<br>

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- HTML 페이지를 먼저 내려받고 남은 트랜잭션이 각각 별도의 커넥션에서 **동시에 처리**된다.
- 커넥션 지연이 겹치면서 총 지연시간이 줄어든다.

<br>

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 네트워크 대역폭이 좁다면 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리다.
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킨다.

<br>

### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황이 보이기 때문에 사용자는 **더 빠르게 내려받는 것처럼** 느낄 수 있다.

<br>

## 4.5 지속 커넥션

- TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다.
- 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 **지속 커넥션**이라고 부른다.
- 새로운 커넥션을 맺기 위한 준비작업의 시간을 절약할 수 있다.
- 이미 맺어져 있는 커넥션은 TCP의 느린 시작으로 인한 지연을 피함으로써 더 빠르게 데이터를 전송한다.

<br>

### 4.5.1 지속 커넥션 VS 병렬 커넥션

**병렬 커넥션의 단점**

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.

**지속 커넥션의 단점**

- 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 될 것이다.
- 그로인해 불필요한 소모를 발생시킨다.

**결론**

- 지속 커넥션은 병렬 커넥션과 함께 사용될 때 가장 효과적이다.
- 오늘날 많은 애플리케이션은 적은 수의 병렬 커넥션만 맺고 그것을 유지한다.
- 두 가지 지속 커넥션 타입: HTTP/1.0+의 `keep-alive` 커넥션, HTTP/1.1의 지속 커넥션

<br>

### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

- 상호 운용과 관련된 설계에 문제가 있었지만 아직 많은 클라이언트와 서버가 이를 사용한다.
- 그 설계상의 문제는 HTTP/1.1에서 수정되었다.

**`keep-alive` 커넥션의 장점**

- 커넥션을 맺고 끊는 데 필요한 작업이 없어 시간이 단축된다.

<br>

### 4.5.3 Keep-Alive 동작

- 클라이언트는 커넥션을 유지하기 위해 요청에 `Connection:Keep-Alive` 헤더를 포함시킨다.
- 서버는 그다음 요청도 이 커넥션을 통해 받고자 한다면 응답 메시지에 같은 헤더를 포함시켜 응답한다.
- 응답에 `Connection:Keep-Alive` 헤더가 없다면 클라이언트는 서버 커넥션을 끊을 것이라 추정한다.

<br>

### 4.5.4 Keep-Alive 옵션

- `keep-alive`의 동작은 `Keep-Alive` 헤더의 쉼표로 구분된 옵션들로 제어할 수 있다.
- `timeout` 파라미터: 커넥션이 얼마간 유지될 것인지 (보장 X)
- `max` 파라미터: 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지 (보장 X)

```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

<br>

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- 커넥션을 계속 유지하려면 모든 메시지에 `Connection: Keep-Alive` 헤더를 포함해 보내야 한다.
- 커넥션이 끊기기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다.
- 프락시와 게이트웨이는 `Connection` 헤더의 규칙을 철저히 지켜야 한다.
- `keep-alive` 커넥션은 `Connection` 헤더를 인식하지 못하는 프락시 서버와는 맺어지면 안 된다.
- HTTP/1.0을 따르는 기기로부터 받는 모든 `Connection` 헤더 필드는 무시해야 한다.
- 클라이언트는 응답을 받기 전 커넥션이 끊어졌을 경우, 요청을 다시 보낼 수 있는 준비가 되어 있어야 한다.

<br>

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

- 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다.
- 잘못된 통신을 피하려면, 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 X

<br>

### 4.5.7 Proxy-Connection 살펴보기

- 클라이언트 요청이 중개서버를 통해 이어지는 경우 모든 헤더를 무조건 전달하는 문제를 해결할 수 있다.

<br>

### 4.5.8 HTTP/1.1의 지속 커넥션

- HTTP/1.0의 `keep-alive` 커넥션과는 달리 HTTP/1.1에서는 기본으로 활성화되어 있다.

<br>

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 커넥션에 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 `Connection: Close` 헤더를 보내야 한다.

<br>

## 4.6 파이프라인 커넥션

- HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝할 수 있다.
- 이는 `keep-alive` 커넥션의 성능을 더 높여준다.

<br>

## 4.7 커넥션 끊기에 대한 미스터리

- 커넥션 관리에는 명확한 기준이 없다.

<br>

### 4.7.1 '마음대로' 커넥션 끊기

- 서버는 지속 커넥션이 유후 상태에 있을 경우 끊을 수 있다.

<br>

### 4.7.2 Content-Length와 Truncation

- 각 HTTP 응답은 본문의 정확한 크기 값을 가지는 `Content-Length` 헤더를 가지고 있어야 한다.

<br>

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 예상치 못하게 커넥션이 끊어졌을 경우를 준비하고 있어야 한다.

<br>

### 4.7.4 우아한 커넥션 끊기

- 애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있다.
