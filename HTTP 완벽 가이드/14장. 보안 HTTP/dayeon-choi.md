# 🐿 [14장] 보안 HTTP

---

# 14.1 HTTP를 안전하게 만들기

* 웹은 안전한 방식의 HTTP를 필요로 함
* HTTP의 보안 버전은 효율적, 이식성, 관리 용이, 적응력이 요구됨

>
* **서버 인증**
위조된 서버가 아님을 알 수 있어야 함
* **클라이언트 인증**
진짜 사용자임을 인증할 수 있어야 함
* **무결성**
위조된 데이터로부터 안전해야 함
* **암호화**
서버와 클라이언트는 도청에 대한 걱정 없이 대화 가능해야 함
* **효율**
저렴한 클라이언트나 서버도 이용할 수 있도록 빠른 알고리즘을 가져야 함
* **편재성**
프로토콜은 모든 클라이언트 서버에서 지원되어야 함
* **관리상 확장성**
누구든, 어디서든 즉각적인 보안 통신 가능해야 함
* **적응성**
현재 알려진 최선의 보안 방법을 지원해야 함
* **사회적 생존성**
사회의 문화적, 정치적 요구를 만족해야 함

### 14.1.1 HTTPS
* HTTP를 안전하게 만드는 방식 중 가장 인기있는 것
* ```https://```
* 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화됨
* SSL (안전 소켓 계층, Secure Sockets Layer)을 이용하여 구현됨

<br/>

# 14.2 디지털 암호학

>
**디지털 암호학에서 다루는 내용**
* **암호**
텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
* **키**
암호의 동작을 변경하는 숫자로 된 매개변수
* **대칭키 암호 체계**
인코딩과 디코딩에 같은 키를 제공하는 알고리즘
* **비대칭키 암호 체계**
인코딩과 디코딩에 다른 키를 사용하는 알고리즘
* **공개키 암호법**
비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
* **디지털 서명**
메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
* **디지털 인증서**
신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학
* 암호법은 메시지 인코딩과 디코딩에 대한 과학이자 기술
* 메시지의 도청, 변조를 방지하기 위해 사용
* 누군가가 메시지, 트랜잭션의 저자임을 증명하는 데도 사용

### 14.2.2 암호(cipher)
* 암호법은 암호라 불리는 비밀 코드에 기반
* 암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법
* 평문 → 암호 적용 → 암호문

### 14.2.3 암호 기계
* 기술이 진보하며 복잡한 암호로 메시지를 코딩하고 디코딩하는 기계, 암호 기계를 만들기 시작
* 단순히 회전을 하는 대신 글자들을 대체하고, 그 순서를 바꾸었으며, 가르고 토막냄

### 14.2.4 키가 있는 암호
* 누군가 기계를 훔치더라도 올바른 다이얼 설정(키 값) 없이는 디코더 동작 불가
* 암호 매개변수를 키라고 부름
* 이 가상 암호 기계들은 서로 다른 키 값을 가지고 있기 때문에 제각각 동작

### 14.2.5 디지털 암호
* 두 가지의 주요한 발전
  * 속도 및 기능에 대한 기계 장치의 한계에서 벗어나, 복잡한 인코딩/디코딩 알고리즘 가능
  * 매우 큰 키를 지원하는 것이 가능해져, 무작위 추측 키에 의한 크래킹 어려워짐

<br/>

# 14.3 대칭키 암호법

* 대칭키 암호 알고리즘은 인코딩과 디코딩에 같은 키를 사용

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)
* 대부분의 경우, 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로 키만이 유일한 비밀
* 무차별로 모든 키 값을 대입해 보는 공격을 열거 공격이라고 함
* 가능한 키 값이 많을 수록 유리

### 14.3.2 공유키 발급하기
* 대칭키 암호의 단점 중 하나는 발송자, 수신자가 서로 대화하려면 둘 다 공유키를 가져야한다는 것
* 기억해야 할 비밀 키가 늘어나게 된다는 단점

<br/>

# 14.4 공개키 암호법

* 두 개의 비대칭 키를 사용
* 인코딩을 위한 하나, 디코딩을 위한 하나
* 키의 분리는 메시지의 인코딩을 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여

### 14.4.1 RSA
>
**공개키 비대칭 암호의 과제**
* 공개키(누구나 얻을 수 있음)
* 가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
* 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)

* 이 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 MT에서 발명되고 있음
* RSA의 소스 코드까지 주어졌다고 하더라도 암호를 크래킹하여 해당하는 개인 키를 찾아내는 것은 매우 어려움

### 14.4.2 혼성 암호 체계와 세션 키
* 공개키의 암호 방식의 알고리즘의 단점은 계산이 느린 경향이 있다는 것
* 때문에 대칭키와 비대칭 방식을 섞어 사용

<br/>

# 14.5 디지털 서명

* 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 인증

### 14.5.1 서명은 암호 체크섬이다
* 서명은 메시지를 작성한 저자가 누군지 알려줌
* 서명은 위조를 방지함
* 디지털 서명은 보통 비대칭 공개키에 의해 생성

<br/>

# 14.6 디지털 인증서

* 흔히 certs라고 불리는 디지털 인증서
* 신뢰할 수 있는 기관으로 부터 보증받은 사용자나 회사에 대한 정보를 담고 있음

### 14.6.1 인증서의 내부
* 대상의 이름, 유효기간, 인증서 발급자, 인증서 발급자의 디지털 서명

### 14.6.2 X.509 v3 인증서
* 불행히, 디지털 인증서에 대한 전 세계적인 단일 표준은 없음
* 미묘하게 다른 여러가지 스타일의 디지털 인증서들이 존재

### 14.6.3 서버 인증을 위한 인증서 사용하기
* 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서 가져옴
* 웹 사이트의 이름과 호스트명, 웹 사이트의 공개키, 서명 기관의 이름, 서명 기관의 서명

<br/>

# 14.7 HTTPS의 세부사항

* HTTPS는 HTTP의 가장 유명한 보안 버전
* HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것
* HTTPS는 인터넷 애플리케이션의 성장 + 웹 기반 전자상거래의 성장을 고속화

### 14.7.1 HTTPS 개요
* HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP
* 암호화되지 않은 HTTP 메시지를 TCP를 보내기 전 보안 계층으로 보냄

### 14.7.2 HTTPS 스킴
* 오늘날 보안 HTTP는 선택, 웹 서버에게 명시 작업이 필요 → URL의 스킴
* HTTPS 프로토콜에서 URL의 스킴 접두사는 ```https```

### 14.7.3 보안 전송 셋업
* 암호화되지 않은 HTTP에서, 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고, 요청 메시지를 보내고, 응답 메시지를 받고, 커넥션을 닫음
* HTTPS에서의 절차는 SSL 보안 계층 때문에 약간 더 복잡
* 443 포트로 연결, 암호법 매개변수와 교환 키 협상으로 SSL 계층 초기화, 핸드셰이크 완료되면 SSL 초기화 완료, 클라이언트가 요청 메시지를 보안 계층에 보냄

### 14.7.4 SSL 핸드셰이크
>
**핸드셰이크에서 일어나는 일들**
* 프로토콜 버전 번호 교환
* 양쪽이 알고 있는 암호 선택
* 양쪽의 신원 인증
* 채널을 암호화하기 위한 임시 세션 키 생성

* 암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고 받음

### 14.7.5 서버 인증서
* SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증 지원
* 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구
* 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그 외의 정보를 보여주는 X.509 v3에서 파생된 인증서

### 14.7.6 사이트 인증서 검사
* 최신 웹 브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 더 철저한 검사를 할 수 있는 방법과 함께 사용자들에게 알려줌
* 날짜 검사 → 서명자 신뢰도 검사 → 서명 검사 → 사이트 신원 검사

### 14.7.7 가상 호스팅과 인증서
* 가상 호스트(하나의 서버에 여러 호스트명)으로 운영되는 사이트 보안 트래픽을 다루는 것은 까다로운 경우도 많음

<br/>

# 14.8 진짜 HTTPS 클라이언트
* SSL은 복잡한 바이너리 프로토콜

### 14.8.1 OpenSSL
* OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현
* OpenSSL 프로젝트는, 강렬한 다목적 암호법 라이브러리인 동시에 SSL과 TLS 프로토콜을 구현한 강건하고 완전한 기능을 갖춘 상용 수준의 툴킷을 개발하고자 한 결과물

### 14.8.2 간단한 HTTPS 클라이언트
* (생략)

### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기
* (생략)

<br/>

# 14.9 프락시를 통한 보안 트래픽 터널링

* 클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용
* HTTPS가 프락시와도 잘 동작할 수 있도록 하기 위해, 클라이언트가 프락시에게 어디에 접속하려고 하는지 말해주는 방법을 약간 수정해야 함 → HTTPS SSL 터널링 프로토콜
