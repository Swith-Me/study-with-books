# 10. HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

- HTTP/1.0의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.
- 심각한 회전 지연을 피할 수 없었다.
- 회전 지연을 줄이기 위해 많은 시도를 했지만 결국 HTTP/2.0을 만드는 것을 계획했다.

<br>

## 10.2 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다.
- HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담긴다.
- HTTP/2.0은 기존의 요청-응답과는 약간 다른 새로운 상호작용 모델인 서버 푸시를 도입했다.

<br>

## 10.3 HTTP/1.1과의 차이점

**1. 프레임**

- HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다.
- 모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.
- 프레임 헤더의 각 필드
- R(2비트), 길이, 종류, 플래그, R(1비트), 스트림 식별자

<br>

**2. 스트림과 멀티플렉싱**

- 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
- HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다.
- 스트림은 우선순위도 가질 수 있다.
- 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다.
- HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다.

<br>

**3. 헤더 압축**

- HTTP/1.0에서 헤더는 아무런 압축 없이 그대로 전송되었다.
- 이를 개선하기 위해 HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다.

<br>

**4. 서버 푸시**

- HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
- 이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.

<br>

## 10.4 알려진 보안 이슈

**중개자 캡슐화 공격**

- HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있다.
- HTTP/1.1과는 달리 HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다.

<br>

**긴 커넥션 유지로 인한 개인정보 누출 우려**

- HTTP/2.0은 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다.
- 이것은 개인 정보의 유출에 악용될 가능성이 있다.