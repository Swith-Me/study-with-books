## 06. 객체와 자료 구조

### 들어가면서

- 변수를 `private`로 정의하는 이유
  - 남들이 맘대로 바꾸지 못하게 하기 위해
- 그렇다면 어째서 수많은 프로그래머가 getter와 setter 함수를 당연하게 `public`으로 설정하여 `private` 변수를 외부에 노출할까?

<br>

### 자료 추상화

- 구현을 감추려면 **추상화**가 필요하다!
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 **진정한 의미의 클래스**이다.
- 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.
- 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.

<br>

### 자료/객체 비대칭

- 객체: 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
- 자료 구조: 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.

**객체 지향 코드 VS 절차적인 코드**  
|내용|객체 지향 코드|절차적인 코드|
|:--------:|:------:|:------:|
|새 함수 추가|difficult|easy|
|새 자료 타입 추가|easy|difficult|

**결론**

> 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.

<br>

### 디미터 법칙

- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
- 객체는 getter로 내부 구조를 공개하면 안 된다.
- 좀 더 정확히 표현하자면,
  > '클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다'
  >
  > - 클래스 C
  > - f가 생성한 객체
  > - f 인수로 넘어온 객체
  > - C 인스턴스 변수에 저장된 객체

<br>

**기차 충돌**

- 다음과 같은 코드는 여러 객차가 한 줄로 이어진 기차처럼 보인다.

```java
// 조잡해 보이므로 피하는 것이 좋다.
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

- 위 코드는 다음과 같이 나누는 편이 좋다.

```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

- 위 예제가 디미터 법칙을 위반하는지 여부는 `ctxt`, `Options`, `ScratchDir`이 객체인지 아니면 자료 구조인지에 달렸다.

<br>

**잡종 구조**

- 때때로 절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다.
- 양쪽 세상에서 단점만 모아놓은 구조이니 되도록 피하는 편이 좋다.

<br>

**구조체 감추기**

- `ctxt`, `Options`, `ScratchDir`이 진짜 객체라면, 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다.
- `ctxt`가 객체라면 뭔가를 하라고 말을 하면 된다.

<br>

### 자료 전달 객체

- 자료 구조체의 전형적인 형태는 `public` 변수만 있고 함수가 없는 클래스이다.
- 이런 자료 구조체를 때로는 자료 전달 객체(DTO)라 한다.
- 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.
- 좀 더 일반적인 형태 '빈(bean) 구조다.
- 빈은 `private` 변수를 getter,setter 함수로 조작한다.

```java
public class Address {
    private String street;
    private String city;

    public Address(String street, String city) {
        ...
    }

    public String getStreet() {
        return street;
    }

    public String getCity() {
        return city;
    }
}
```

**활성 레코드**

- 활성 레코드는 DTO의 특수한 형태다.
- `public` 변수가 있거나 `private` 변수에 getter, setter 함수가 있는 자료구조
- 대게 `save`, `find와` 같은 탐색 함수도 제공한다.
- 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과이다.
- 활성 레코드를 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성하여 **객체로 취급하지 않는다.**

<br>

### 결론

**객체**

- 객체는 동작을 공개하고 자료를 숨긴다.
- 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기 쉽다.
- 기존 객체에 새 동작을 추가하기는 어렵다.

**자료 구조**

- 별다른 동작 없이 자료를 노출한다.
- 기존 자료 구조에 새 동작을 추가하기는 쉽다.
- 기존 함수에 새 자료 구조를 추가하기는 어렵다.

**시스템을 구현할 때**

- 새로운 자료 타입을 추가하는 유연성이 필요하면 👉 객체
- 새로운 동작을 추가하는 유연성이 필요하면 👉 자료 구조

<br>

### 느낀점

- 처음 읽을 때는 너무 이해가 안가서 코드를 몇번이고 봤다.
- 그러다보니 객체와 자료 구조의 차이점을 알게되고 자연스럽게 어떨 때 써야 좋을지도 알게되었다.
- P.S. 예전에 배웠던 자바가 새록새록 기억이 났다...ㅎ
