# 11. 시스템

> **목표**✔ <br>
> 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴보자
<br>

## I. 시스템 제작과 시스템 사용을 분리하라
> 제작(construction)은 사용(use)과 아주 다르다. 소프트웨어 시스템은 준비과정과, 이후에 이어지는 런타임 로직을 분리해야 한다.

#### Main 분리
시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로, <br>
생성과 관련된 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, <br>
나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

![image](https://user-images.githubusercontent.com/63613093/126901903-d0ed24d0-f447-41ab-a7ee-9728f5e6fbbc.png)

<br>

#### 팩토리
객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.

![image](https://user-images.githubusercontent.com/63613093/126901911-ba641d22-0400-4db8-9511-7b18cc983b4c.png)

<br>

#### 의존성 주입
- 사용과 제작을 **분리**하는 강력한 메커니즘 
- **제어 역전 기법**을 **의존성 관리**에 적용한 메커니즘

<br><br>

## II. 확장
> 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

#### 횡단(cross-cutting)관심사
> 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다.

원론적으로 모듈화되고 캡슐화된 방식으로 영속성 방식 구상 가능 <br>
➜ 현실적으론, 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. <br>
➜ **횡단 관심사** 등장

<br><br>

## III. 자바 프록시
- 자바 프록시는 **단순한 상황**에 적합 <br>
  - ex) 개별 객체나 클래스에서 메서드 호출 감싸기
- 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다. 
- 프록시는 시스템 단위로 실행'지점'을 명시하는 메커니즘을 제공하지 않는다.

<br><br>

## IV. 순수 자바 AOP 프레임워크
- 대부분의 프레임 워크는 도구로 자동화 가능
- 순수 자바 관점을 구현하는 스프링AOP, JBoss AOP 등과 같은 여러 자바 프레임어크는 내부적으로 프록시 사용

![image](https://user-images.githubusercontent.com/63613093/126902295-2963d79d-c929-4579-a3e7-8e1d7c4ddd90.png)

<br><br>

## V. AsprectJ 관점
> 관심사를 **관점으로 분리**하는 가장 강력한 도구는 AspectJ언어다.

**AspectJ란**❓ <br>
언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장 <br>
- 장점 : 관점을 분리하는 강력하고 풍부한 도구 집합 제공
- 단점 : 새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 한다.

<br><br>

## VI. 테스트 주도 시스템 아키텍처 
> 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.

<br><br>

## VII. 의사 결정을 최적화하라
> 우리는 때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선이라는 사실을 까먹곤 한다.

**최대한 정보를 모아 최선의 결정을 내리자.** <br>
성급한 결정은 불충분한 지식으로 내린 결정일 뿐이다.
 
<br><br>

## VIII. 명백한 가치가 있을 때 표준을 현명하게 사용하라
> 과장되게 포장된 표준에 집착하다가 고객 가치를 뒷전으로 미루지 말자.

**표준 사용**
- 장점
  - 아이디어와 컴포넌트 재사용 용이
  - 적절한 경험을 가진 인재 구인 가능
  - 좋은 아이디어 캡슐화, 컴포넌트 엮기 용이
  - 
- 단점
  - 업계의 요구에 맞추지 못하는 표준 제작시간
  - 본래 표준 제정 목적의 상실

<br><br>

## IX. 시스템은 도메인 특화 언어가 필요하다
> 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여준다.

- 도메인을 잘못 구현할 가능성 감소
- 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다.
  - 개발자가 적절한 추상화 수준에서 코드 의도 표현 가능

**도메인 특화 언어(DSL)를 사용하면**❓ <br>
고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다.
   
<br><br>

## X. 결론
> 시스템은 역시 깨끗해야 한다.

- 낮은 생산성으로 TDD가 제공하는 장점 상실에 주의
- 모든 추상화 단계에서 의도를 명확히 표현
  - POJO작성+관점과 유사한 메커니즘을 사용해 각 구현 관심사 분리
- 실제로 돌아가는 가장 단순한 수단을 사용


<br>

***

⚡ **"복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다."**




