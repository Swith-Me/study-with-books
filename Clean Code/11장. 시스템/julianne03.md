## 11. 시스템

### 들어가면서

> 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.

<br>

**도시를 세운다면?**

- 소프트웨어 팀도 도시처럼 구성한다.
- 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.
- 이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.

<br>

### 시스템 제작과 시스템 사용을 분리하라

- 제작과 사용은 아주 다르다.
- 다음과 같이 여러 분리 방법들을 살펴보자.

**Main 분리**

- 생성과 관련된 코드는 모두 main이나 main이 호출하는 모듈로 옮기고 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

**팩토리**

- 어떤 경우에는 생성에 관련된 부분을 애플리케이션이 결정할 필요가 있다. 그런 부분은 Factory Pattern을 사용하여 애플리케이션이 결정하지만 직접 생성하는 부분의 연관성을 제거한다.

**의존성 주입**

- 제어 역전 기법을 의존성 관리에 적용한 매커니즘이다.

<br>

### 확장

- 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.
- 이것이 반복적이고 점진적인 애자일 방식의 핵심이다.
- 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.

<br>

### 테스트 주도 시스템 아키텍처 구축

- 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.
- 아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장해 나가도 괜찮다.

<br>

### 의사 결정을 최적화하라

- 우리는 때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선이라는 사실을 까먹곤 한다.
- 최대한 정보를 모아 최선의 결정을 하기 위해서다.

<br>

### 명백한 가치가 있을 때 표준을 현명하게 사용하라

- 여러 형태로 아주 과장되게 포장된 표준에 집착해 고객 가치가 뒷전으로 밀리는 일과 같은 상황을 만들지 말자.
- 그러다 보면 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다.

<br>

### 시스템은 도메인 특화 언어가 필요하다

- DSL : 간단한 스크립트 언어나 표준 언어로 구현된 API
- 효과적으로 사용한다면 DSL은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다.
- 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다.

<br>

### 결론

- 시스템은 역시 깨끗해야 한다.
- 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기만성을 떨어뜨린다.
- 도메인 논리가 흐려지면 제품 품질이 떨어진다.
- 버그가 숨어들기 쉬워지고, 스토리를 구현하기 어려워진다.
- TDD가 제공하는 장점이 사라진다.

<br>

**시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자.**

<br>

### 느낀점

- 모든 것(시스템, 모듈, 함수, 클래스)를 설계할 때 가장 중요한 것은 미래에 대비하여 깨끗한 코드를 짜는 것이다.
- 이번 장에서도 나왔듯이 시스템 수준에서도 깨끗함을 유지해야 한다는 점을 명심하자.
