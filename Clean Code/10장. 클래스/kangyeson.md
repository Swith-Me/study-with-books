# 10. 클래스

## I. 클래스 체계
1. 변수 목록 & 정적(static) 공개(public) 상수
2. 정적 비공개(private) 변수
3. 비공개 인스턴스 변수 (공개 변수가 필요한 경우는 거의 없다.)
4. 공개 함수
5. 비공개 함수는 자신을 호출하는 공개 함수 직후에

➔ 추상화 단계가 순차적으로 내려간다.

#### 캡슐화
> 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

✔ 변수나 유틸리티 함수를 protected로 선언해 테스트 코드에 접근 허용 <br>
👍 하지만 가능한 공개하지 않는 편이 낫다. 

<br><br>

## II. 클래스는 작아야 한다!
> 클래스가 맡은 **책임**이 가능한 작아야 한다.
- 클래스 이름은 해당 클래스 책임을 기술
  - Processor, Manager, Supter 등과 같은 모호한 단어 = 클래스에 여러 책임을 떠안겼다는 증거
- 클래스 설명은 만약(if), 그리고(and), ~하며(or), 하지만(but)을 사용하지 않고 25단어 내외로 가능해야 한다. <br><br>

#### 단일 책임 원칙(SRP)
> 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다.

책임, 즉 변경할 이유를 파악하려다보면 코드를 추상화하기도 쉬워진다.<br>
큰 클래스 몇개보다 작은 클래스 여러개가 바람직하다. <br>
✔ 작은 클래스 
- 각자 맡은 책임이 하나
- 변경할 이유가 하나
- 다른 작은 클래스와 협력해 시스템에 필요한 동작 수행 <br><br>

#### 응집도(Cohesion)
> 클래스는 인스터스 변수 수가 작아야 한다.

✔ 응집도가 높은 클래스
- 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미
- 변수와 메서드를 분리, 새로운 클래스 두세 개로 쪼개어 만들어준다. <br><br>

#### 응집도를 유지하면 작은 클래스 여럿이 나온다
> 클래스가 응집력을 잃는다면 쪼개라!

❌ 몇몇 함수만 사용하는 인스턴스 변수 증가 ➔ 응집력 약화 <br>
✔ 몇몇 함수가 몇몇 변수만 사용 ➔ 독자적인 클래스로 분리 ➔ 응집력 유지 <br><br>

#### 리펙터링 후 길이가 늘어난 이유
1. 리펙터링한 프로그램은 좀 더 길고 서술적인 변수 이름을 사용
2. 리펙터링한 프로그램은 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용
3. 가독성을 높이고자 공백을 추가하고 형식 설정

<br><br>

## III. 변경하기 쉬운 클래스
> 대다수 시스템은 지속적인 변경이 가해진다. 그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다. <br>
> **깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.**

#### 이상적인 시스템 구조<br>
- 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소
- 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드는 변경하지 않는다. 

#### 변경으로부터 격리
> 요구사항은 변하기 마련, 따라서 코드도 변하기 마련이다.

시스템 요소를 다른 요소로부터 그리고 변경으로부터 격리 <br>
➔ 각 요소 이해도 상승 <br>
➔ 유연성과 재사용성 상승 <br><br>

👉 **결합도가 낮은 상태**가 바람직 <br>
결합도를 최소로 줄이면 자연스럽게 클래스 설계 원칙인 DIP를 따르는 클래스가 나온다. <br>
본직적으로 DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.
   
<br>





