✨ 제 3장, 함수 
----------------------

### 작게 만들어라
> * 함수를 만드는 규칙은 첫째도 작게, 둘째도 작게!
>
> * 블록과 들여쓰기 <br>
>   - if문/else문/while문 등에 들어가는 블록은 한 줄이 적당 <br>
>   - 중첩 구조가 생길만큼 함수가 커지면 안되므로, 들여쓰기 수준은 1, 2단을 넘기면 X <br>

<br/>

### 한 가지만 해라 
> * __함수는 한 가지를 해야 한다. 그 한가지를 잘 해야 한다. 그 한가지만을 해야 한다.__  <br>
> * 함수 이름 아래에서 추상화 수준이 한 개 <br>
> * 단순히 다른 표혐이 아니라 의미 있는 이름으로 다른 함수 추출이 가능 X

<br/>

### 함수 당 추상화 수준은 하나로
> * 모든 문장의 추상화 수준이 동일해야 함수가 확실히 __한 가지 작업만 수행__ <br>
> * 위에서 아래로 코드 읽기 ; 내려가기 규칙
>   - 위에서 아래로 이야기처럼 읽히는 것 <br>
추상화 수준 매우 높음
~~~java
getHtml()
~~~
추상화 수준 중간
~~~java
Strign pagePathName = pathParser.render(pagepath);
~~~
추상화 수준 매우 낮음
~~~java
.append("\n")
~~~

<br/>

### Switch문 
> * 작게 만들기 어렵 <br>
> * 효율적인 Switch문 <br>
>   - 다형성을 이용해 Swithch 문을 저차원 클래스에 숨기고 반복 X <br>
>   - SPR (Single Responsibility Principle) 위반 X <br>
>   - OCP (Open Principle) 위반 X <br>

<br/>

### 서술적인 이름을 사용하라 
> * __코드를 읽으면서 짐작했던 기능을각 루틴이 그대로 수행한다면, 깨끗한 코드__ <br> 
> * 길고 서술적인 이름 > 짧고 어려운 이름 (길고 서술적인 주석) <br>
> * 여러 단어가 쉽게 읽히는 명명법 사용
> * IDE를 이용해 더 쉽게 이름 변경 

<br/>

### 함수 인수
> * O ; 무항 (0개, 가장 이상적인 인수) -> 단항 (1개) -> 이항 (2개)  <br> 
> * X ; 삼항 (3개, 사용 자제) -> 다항 (4개, 특별한 이유있어도 사용 금지)  <br> 

>많이 쓰는 단항 형식 (인수 1개)<br>

인수에 질문을 던지는 경우 <br>
  ~~~java
  boolean fileExists("MyFile")
  ~~~
인수를 로 변환해 결과를 반환하는 경우 <br>
  ~~~java
  InputSteam fileOpen("MyFile") //stpring형의 파일 이름 -> InputStream 
  ~~~
이벤트 (입력 인수만 존재, 출력 인수 X)<br>
  ~~~java
  passwordAttemptFailedNtimes(int attempts)
  ~~~
  
>플래그 인수
> * 함수로 부울 값을 넘기는 관례는 함수가 여러 가지를 한꺼번에 처리한다는 것을 공표하는 셈 

>이항 함수 (인수 2개)
이항 함수의 좋은 예 <br>
  ~~~java
  Point p = new Point(0, 0) 
  ~~~

>삼항 함수 (인수 3개)
다음 함수는 부동소수점 비교가 상대적이므로, 가치 충분 <br>
  ~~~java
  asserEquals(1, 0, amount, 001) 
  ~~~

>인수 객체 
> * 객체를 생성해 인수를 줄이는 방법은 눈속임 X 
> - 변수를 묶어 넘기면, 이름이 붙음 (결국에는 개념을 포함) <br>
  ~~~java
  Circle makeCircle(double x, double y, double radius);
  Circle makeCircle(Point center, double radius);
  ~~~

>인수 목록
> * 가변 인수를취하는 함수는 단항, 이항, 삼항 함수로 취급 가능 (but, 적당히) 

>동사와 키워드 
> * 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 함 
함수 이름에 키워드 추가
>   - assertExpectedEqualsActual(expected, actual) 

<br/>

### 부수 효과를 일으키지 마라 
> * 클래스 변수 수정
> * 함수로 넘어온 인수, 시스템 전역 변수 수정
>   - 시간적 결합, 순서 종속성 초래 <br>

>출력 인수
> * 객체 지향 언어에서는 출력 인수 사용할 필요 X
>   - this 사용  

### 명령과 조회를 분리하라
> * 함수 ; 객체 상태 변경 or 객체 정보 반환 

<br/>

### 오류 코드보다 예외를 사용하라
> * 오류 코드를 반환하는 방식 ; 명령/조회 분리 규칙을 미묘하게 위반
> * 오류 코드 대신 예외 사용
>   - 오류 처리 코드가 원래 코드에서 분리되므로 코드 깔끔 

<br/>

### 반복하지 마라 
> * 중복은 소프트웨어에서 모든 악의 근원 
> * 중복을 없애면, 모듈 가독성이 크게 높아짐 

<br/>

### 구조적 프로그래밍
> * 에츠허르 데이크스트라의 구조적 프로그매이 원칙
>   - 모든 함수와 함수 내 블록에 입구와 출구가 하나만 존재 (return문이 1개라는 뜻)
>   - 루트 속 break, continue, goto 사용 X
> * But,함수를 작게 만든다면, return, break, countinue를 사용해도 O
> * 단일 입/출구 규칙보다 의도 표현이 쉬워질수도! 



