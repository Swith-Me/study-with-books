## 8장 경계

### 외부코드 사용하기
Sensor라는 객체를 담는 Map 생성
```
Map sensors = new HashMap();
```
Sensor 객체가 필요한 코드는 다음과 같이 Sensor 객체를 가져온다
```
Sensor s = (Sensor)sensors.get(sensorId);
```
위와 같은 코든느 한 번이 아니라 여러 차례 나오기 대문에 깨끗한 코드라 보기 여려우며, 의도도 분명히 드러나지 않는다

```
public class Sensors {
  private Map sensors = new HashMap();
  
  public Sensor getById(String id) {
    return (Sensor) sensors.get(id);
  }
  //이하 생략
}
```
* Map을 깔끔하게 사용한 코드로, Map을 Sensor 안으로 숨긴다
* Map 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다
* Map과 같은 경계 인터페이스를 이용할 때는 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다
------------
### 경계 살피고 익히기
* 학습 테스트 : 우리쪽 코드를 작성해 외부코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것
------------
### 학습 테스트는 꽁자 이상이다
* 학습 테스트에 드는 비용은 없다
* 학습 테스트는 패키지가 예상대로 도는지 검증한다
------------
### 아직 존재하지 않는 코드를 사용하기
* 우리가 바라는 인터페이스를 구현하면 생기는 장점
  1. 인터페이스를 전적으로 통제함
  2. 코드의 가독성이 높아짐
  3. 코드의 의도가 분명해짐
------------
### 깨끗한 경계
* 경계에 위치하는 코드는 깔끔히 분리하고, 기대치를 정의하는 테스트 케이스도 작성한다
* 통제 불가능한 외부 패키지에 의존하는 것보다 통제 가능한 우리 코드에 의존하는 편이 좋다
* 외부 패키지를 호출하는 코드를 줄여 경계를 관리하자
