## 08. 경계

### 들어가면서

- 어떤 식으로든 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다.
- 이 장에서는 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.

<br>

### 외부 코드 사용하기

- 패키지 제공자나 프레임워크 제공자 : 적용성을 최대한 넓히려 애쓴다.
- 사용자 : 자신의 요구에 집중하는 인터페이스를 바란다.

이 둘 사이의 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.

```java
// 경계 인터페이스인 Map을 Sensors 클래스 안으로 숨긴다.
public class Sensors {
    // Map 객체 선언
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
    // 이하 생략
}
```

- `Map` 인터페이스가 변하더라도 나머지 프로그램에 영향을 미치지 않음
- `Sensors` 클래스 안에서 객체 유형을 관리, 변환하기 때문에 제네릭스 필요 x
- `Sensors` 클래스는 프로그램에 필요한 인터페이스만 제공

**결론**

- Map을 여기저기 넘기지 말아라.
- Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의
- Map 인스턴스를 공개 API 인수로 넘기거나 반환값으로 사용하지 말아라.

<br>

### 경계 살피고 익히기

- 짐 뉴커크의 **학습 테스트**
  - 외부 코드를 호출하기 전 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히자.
  - 프로그램에서 사용하려는 방식대로 외부 API를 호출한다.
  - API를 사용하려는 목적에 초점을 맞춘다.

<br>

### 학습 테스트는 공짜 이상이다

- 학습 테스트에 투자하는 노력보다 얻는 성과가 더 크다.
- 학습 테스트는 패키지가 예상대로 도는지 검증한다.
- 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.

<br>

### 아직 존재하지 않는 코드를 사용하기

- 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계이다.
- 때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다.
- 하지만 우리가 바라는 인터페이스를 먼저 구현할 경우, 알지 못했던 코드와 연결하는 것이 쉬워진다.

<br>

### 깨끗한 경계

- 경계에서는 흥미로운 일이 많이 벌어지는 데 대표적인 예는 **변경**이다.
- 경계에 위치하는 코드는 깔끔히 분리한다.
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
- 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.

**효과**

- 코드 가독성이 높아진다.
- 경계 인터페이스를 사용하는 일관성이 높아진다.
- 외부 패키지가 변했을 때 변경할 코드도 줄어든다.

<br>

### 느낀점

- 현재는 내가 자바 언어로 코드를 쓰지 않아서 와닿지 않는 부분이 있기도 했다.
- 하지만 경계의 의미를 들었을 때, 내가 현재 그렇게 코드를 짜고 있나? 라는 생각이 들었다.
- 또한 이 장에서 설명했던 기법들은 모든 곳에서나 쓰일 수 있고 쓰면 클린 코드가 될 것 같다는 생각이 들었다.
