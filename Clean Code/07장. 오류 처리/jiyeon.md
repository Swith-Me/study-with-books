## 7장 오류처리

* 프로그램에 반드시 필요한 요소
* 깨끗한 코드와의 연관성
------------
### 오류 코드보다 예외를 사용하라
* 예외를 사용하는 편이 호출자 코드가 더 깔끔해지고, 논리가 오류처리 코드와 뒤섞이지 않는다
```
try{
  function()
} catch (Error e) {
  logger.log(e);
}
```
------------
### Try-Catch-Finally 문부터 작성하라
* 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다
  그러면 자연스럽게 try블록의 트랙잭션 범위를 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다
------------
### 미확인(unchecked)예외를 사용하라
* 최하위 함수를 변경해 새로운 오류를 던지게 되면 최하위 단계에서 최상위 단계까지 연쇄적인 수정이 일어나고, 캡슐화가 깨진다
------------
### 예외에 의미를 제공하라
* 오류 메세지에 정보를 담아 예외와 함께 던지고, 실패한 연산 이름과 실패 유형도 언급한다
------------
### 호출자를 고려해 예외 클래스를 정의하라
* 외부 API를 사용할 때는 감싸기 기법이 최선이다
* 외부 API 감싸기 기법의 장점
  1. 외부 라이브러리와 프로그램 사이의 의존성이 줄어든다
  2. 다른 라이브러리로 갈아타도 비용이 적게든다
  3. 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다
  4. 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다
------------
### 정상 흐름을 정의하라
* 특수 사례 패턴 : 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식 (클라이언트 코드가 예외적인 상황 처리 X)
------------
### null을 반환하지 마라
* null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다
* 메서드에서 null을 반환하고픈 유혹이 든다면 예외를 던지거나, 특수 사례 객체를 반환한다
------------
### null을 전달하지 마라
* null을 반환하는 방식보다 더 나쁜 방식
* 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다
------------
### 결론
* 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다
