✨ 제 7장, 오류 처리
----------------------

### 오류 코드보다 예외를 사용하라 
> * 논리가 오류 처리 코드가 뒤섞이지 않아 호출자 코드가 깔끔해짐 

<br/>

### Try-Catch-Finally문부터 작성하라
> * 예외 발생 코드를 짤 때, try-catch-finally문으로 시작하는 편이 best!
>   - 호출자가 기대하는 상태를 정의하기 쉬움  
> * 예외를 일으키는 테스트 케이스를 작성하고 테스트를 통과하게 코드 작성
>   - 범위 내 트랜잭션 본질 유지가 쉬움 

<br/>

### 미확인 예외를 사용하라  
> * 확인된 예외
>   - 안정된 소프트웨어를 제작하는 요소로 반드시 필요 X
> * 확인된 예외가 필요하지 않은 이유 
>   - OCP 위반 
>   - 캡슐화가 깨짐
>   - 하위 단계 코드 변경 시 상위 단계 코드를 전부 수정해야하는 불편함 
> * 확인된 예외가 필요한 경우 
>   - 중요한 라이브러리를 작성할 때 (모든 예외를 잡음) 

<br/>

### 예외에 의미를 제공하라 
> * 예외 던질 때, 전후 상황 덧붙이기
>   - 오류가 발생한 원인과 위치 찾기 수월 

<br/>

### 호출자를 고려해 예외 클래스를 정의하라 
> * 우리가 오류를 처리하는 방식 
>   - 1) 오류를 기록하기
>   - 2) 프로그램을 계속 수행해도 좋은지 확인하기 
> * 호출하는 라이브러리 API를 감싸는 기법  
>   - 외부 라이브러리와 프로그램 사이의 의존성이 떨어짐.
>   - 프로그램 테스트가 쉬워짐 
>   - 프로그램이 사용하기 편리한 API를 사용하면 그만, 설계 방식에 얽매이지 않음 

<br/>

### 정상 흐름을 정의하라 

예외가 논리를 따라가기 어려운 코드
~~~java
try { 
  MealExpenses expensees = expenseReportDAO.getMeals(employee.getID());
  m_total += expenses.getTotal();
} catch(MealExpensesNotFound e) {
  m_total += getMEalPerDiem();
}
~~~

간결해진 코드 
~~~java
MealExpenses expensees = expenseReportDAO.getMeals(employee.getID());
m_total += expenses.getTotal();
~~~

> * 특수 사례 패턴 
>   - 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식
>   - 클라이언트 코드가 예외 상황을 처리할 필요 X

<br/>

### null을 반환하지 마라 
> * 일거리를 늘리고 호출자에게 문제를 떠넘김
> * __null을 반환하지 말고, 특수 사레 객체를 사용해라!__

<br/>

### null을 전달하지 마라 
> * 정상적인 인수로 null을 기대하는 API가 아니라면, 메서드로 null을 전달하는 코드 최대한 기피
> * 대체 방법  
>   - 새로운 예외 유형을 생성해 던지기
>   - assert문 사용하기 
